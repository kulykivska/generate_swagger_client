/**
 * project REST API
 * Specification of REST API for Project
 *
 * OpenAPI spec version: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { AddFeedbackRequest } from '../model/addFeedbackRequest';
import { BasicUsersAsList } from '../model/basicUsersAsList';
import { Body } from '../model/body';
import { ClientErrorResponse } from '../model/clientErrorResponse';
import { Communities } from '../model/communities';
import { Community } from '../model/community';
import { CommunityInviteOrDeclineRequest } from '../model/communityInviteOrDeclineRequest';
import { ConnectionRequestStatus } from '../model/connectionRequestStatus';
import { Connections } from '../model/connections';
import { Conversation } from '../model/conversation';
import { CounselRole } from '../model/counselRole';
import { CounselUsersByType } from '../model/counselUsersByType';
import { CovidMapData } from '../model/covidMapData';
import { CovidVaccinationsMapData } from '../model/covidVaccinationsMapData';
import { CreateCommentRequest } from '../model/createCommentRequest';
import { CreateCommunityRequest } from '../model/createCommunityRequest';
import { CreateConversationRequest } from '../model/createConversationRequest';
import { CreateFolderRequest } from '../model/createFolderRequest';
import { CreatePostRequest } from '../model/createPostRequest';
import { CreateProjectRequest } from '../model/createProjectRequest';
import { EmptyResponse } from '../model/emptyResponse';
import { FileActivityLog } from '../model/fileActivityLog';
import { FileDescriptor } from '../model/fileDescriptor';
import { FileSizeResponse } from '../model/fileSizeResponse';
import { FilesActivityLog } from '../model/filesActivityLog';
import { FolderDescriptor } from '../model/folderDescriptor';
import { FoldersResponse } from '../model/foldersResponse';
import { FullUser } from '../model/fullUser';
import { FullUserUpdateRequest } from '../model/fullUserUpdateRequest';
import { GenerateDownloadFileUrlResponse } from '../model/generateDownloadFileUrlResponse';
import { GenerateFileRequest } from '../model/generateFileRequest';
import { GenerateFileResponse } from '../model/generateFileResponse';
import { InlineResponse201 } from '../model/inlineResponse201';
import { ListOfBasicUsers } from '../model/listOfBasicUsers';
import { ListOfCommentReplies } from '../model/listOfCommentReplies';
import { ListOfExtendedUsers } from '../model/listOfExtendedUsers';
import { ListOfRootComments } from '../model/listOfRootComments';
import { LoginRequest } from '../model/loginRequest';
import { LoginResponse } from '../model/loginResponse';
import { MessagingAccessToken } from '../model/messagingAccessToken';
import { MessagingChannelBasic } from '../model/messagingChannelBasic';
import { PaginatablePendingUserInvolvementsInCommunities } from '../model/paginatablePendingUserInvolvementsInCommunities';
import { PaginatablePendingUserInvolvementsInProjects } from '../model/paginatablePendingUserInvolvementsInProjects';
import { PendingUserInvolvements } from '../model/pendingUserInvolvements';
import { PermissionErrorResponse } from '../model/permissionErrorResponse';
import { PhoneNumberRequest } from '../model/phoneNumberRequest';
import { Post } from '../model/post';
import { Posts } from '../model/posts';
import { Project } from '../model/project';
import { ProjectInviteOrDeclineRequest } from '../model/projectInviteOrDeclineRequest';
import { ProjectRequest } from '../model/projectRequest';
import { ProjectRequests } from '../model/projectRequests';
import { Projects } from '../model/projects';
import { ReplyComment } from '../model/replyComment';
import { ReplyCommentRequest } from '../model/replyCommentRequest';
import { RequestCounters } from '../model/requestCounters';
import { RequestCountersBasic } from '../model/requestCountersBasic';
import { ResetPasswordBody } from '../model/resetPasswordBody';
import { ResetPasswordChangeBody } from '../model/resetPasswordChangeBody';
import { RootComment } from '../model/rootComment';
import { SearchAggregationResponse } from '../model/searchAggregationResponse';
import { SearchAttributesResponse } from '../model/searchAttributesResponse';
import { SearchResponse } from '../model/searchResponse';
import { ShareRequest } from '../model/shareRequest';
import { SignupIndividualRequest } from '../model/signupIndividualRequest';
import { SignupOrganizationRequest } from '../model/signupOrganizationRequest';
import { Statistics } from '../model/statistics';
import { UpdateCommunityRequest } from '../model/updateCommunityRequest';
import { UpdateConversationTitleRequest } from '../model/updateConversationTitleRequest';
import { UpdateFileStorageItemRequest } from '../model/updateFileStorageItemRequest';
import { UpdatePostRequest } from '../model/updatePostRequest';
import { UpdateProjectRequest } from '../model/updateProjectRequest';
import { UserChangePassword } from '../model/userChangePassword';
import { UserId } from '../model/userId';
import { UserIdRequest } from '../model/userIdRequest';
import { UserSocialGroupsStats } from '../model/userSocialGroupsStats';
import { ValidateResetPasswordTokenBody } from '../model/validateResetPasswordTokenBody';
import { VerificationProjectRequest } from '../model/verificationProjectRequest';
import { VerifyOneTimeCodeRequest } from '../model/verifyOneTimeCodeRequest';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DefaultService {

    protected basePath = 'https://localhost:8080';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Fetch all project verification requests
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restAdminProjectsIndex(observe?: 'body', reportProgress?: boolean): Observable<ProjectRequests>;
    public restAdminProjectsIndex(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProjectRequests>>;
    public restAdminProjectsIndex(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProjectRequests>>;
    public restAdminProjectsIndex(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ProjectRequests>('get',`${this.basePath}/admin/verification/projects`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Drop a project verification request
     * 
     * @param requestId Request Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restAdminProjectsPatch(requestId: string, observe?: 'body', reportProgress?: boolean): Observable<ProjectRequest>;
    public restAdminProjectsPatch(requestId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProjectRequest>>;
    public restAdminProjectsPatch(requestId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProjectRequest>>;
    public restAdminProjectsPatch(requestId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling restAdminProjectsPatch.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ProjectRequest>('patch',`${this.basePath}/admin/verification/project/${encodeURIComponent(String(requestId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Take a project verification request
     * 
     * @param requestId Request Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restAdminProjectsPost(requestId: string, observe?: 'body', reportProgress?: boolean): Observable<ProjectRequest>;
    public restAdminProjectsPost(requestId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProjectRequest>>;
    public restAdminProjectsPost(requestId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProjectRequest>>;
    public restAdminProjectsPost(requestId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling restAdminProjectsPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ProjectRequest>('post',`${this.basePath}/admin/verification/project/${encodeURIComponent(String(requestId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update project verification status
     * 
     * @param body 
     * @param requestId Request Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restAdminProjectsPut(body: VerificationProjectRequest, requestId: string, observe?: 'body', reportProgress?: boolean): Observable<ProjectRequest>;
    public restAdminProjectsPut(body: VerificationProjectRequest, requestId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProjectRequest>>;
    public restAdminProjectsPut(body: VerificationProjectRequest, requestId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProjectRequest>>;
    public restAdminProjectsPut(body: VerificationProjectRequest, requestId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restAdminProjectsPut.');
        }

        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling restAdminProjectsPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ProjectRequest>('put',`${this.basePath}/admin/verification/project/${encodeURIComponent(String(requestId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Logs previously registered user in
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restAuthLoginPost(body: LoginRequest, observe?: 'body', reportProgress?: boolean): Observable<LoginResponse>;
    public restAuthLoginPost(body: LoginRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LoginResponse>>;
    public restAuthLoginPost(body: LoginRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LoginResponse>>;
    public restAuthLoginPost(body: LoginRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restAuthLoginPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<LoginResponse>('post',`${this.basePath}/auth/login`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Log out user from the currently open session
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restAuthLogoutPost(observe?: 'body', reportProgress?: boolean): Observable<EmptyResponse>;
    public restAuthLogoutPost(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyResponse>>;
    public restAuthLogoutPost(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyResponse>>;
    public restAuthLogoutPost(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyResponse>('post',`${this.basePath}/auth/logout`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Requests to prolong duration of the session (user activity on the client side)
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restAuthProlongPost(observe?: 'body', reportProgress?: boolean): Observable<EmptyResponse>;
    public restAuthProlongPost(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyResponse>>;
    public restAuthProlongPost(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyResponse>>;
    public restAuthProlongPost(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyResponse>('post',`${this.basePath}/auth/prolong`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Request one time code
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restAuthRequestOneTimeCodePost(body: PhoneNumberRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restAuthRequestOneTimeCodePost(body: PhoneNumberRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restAuthRequestOneTimeCodePost(body: PhoneNumberRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restAuthRequestOneTimeCodePost(body: PhoneNumberRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restAuthRequestOneTimeCodePost.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/auth/request_one_time_code`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Resend verification email to user
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restAuthResendVerificationEmailPost(body: ResetPasswordBody, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restAuthResendVerificationEmailPost(body: ResetPasswordBody, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restAuthResendVerificationEmailPost(body: ResetPasswordBody, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restAuthResendVerificationEmailPost(body: ResetPasswordBody, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restAuthResendVerificationEmailPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/auth/resend_verification_email`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Reset password request - send email to user
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restAuthResetPasswordPost(body: ResetPasswordBody, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restAuthResetPasswordPost(body: ResetPasswordBody, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restAuthResetPasswordPost(body: ResetPasswordBody, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restAuthResetPasswordPost(body: ResetPasswordBody, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restAuthResetPasswordPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/auth/reset_password`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Change password after email link
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restAuthResetPasswordPut(body: ResetPasswordChangeBody, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restAuthResetPasswordPut(body: ResetPasswordChangeBody, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restAuthResetPasswordPut(body: ResetPasswordChangeBody, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restAuthResetPasswordPut(body: ResetPasswordChangeBody, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restAuthResetPasswordPut.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/auth/reset_password`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Registers new individual user in the system
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restAuthSignupIndividualPost(body: SignupIndividualRequest, observe?: 'body', reportProgress?: boolean): Observable<UserId>;
    public restAuthSignupIndividualPost(body: SignupIndividualRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserId>>;
    public restAuthSignupIndividualPost(body: SignupIndividualRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserId>>;
    public restAuthSignupIndividualPost(body: SignupIndividualRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restAuthSignupIndividualPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<UserId>('post',`${this.basePath}/auth/signup/individual`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Registers new organization user in the system
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restAuthSignupOrganizationPost(body: SignupOrganizationRequest, observe?: 'body', reportProgress?: boolean): Observable<UserId>;
    public restAuthSignupOrganizationPost(body: SignupOrganizationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserId>>;
    public restAuthSignupOrganizationPost(body: SignupOrganizationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserId>>;
    public restAuthSignupOrganizationPost(body: SignupOrganizationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restAuthSignupOrganizationPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<UserId>('post',`${this.basePath}/auth/signup/organization`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Validate reset password token
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restAuthValidateResetPasswordTokenPost(body: ValidateResetPasswordTokenBody, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restAuthValidateResetPasswordTokenPost(body: ValidateResetPasswordTokenBody, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restAuthValidateResetPasswordTokenPost(body: ValidateResetPasswordTokenBody, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restAuthValidateResetPasswordTokenPost(body: ValidateResetPasswordTokenBody, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restAuthValidateResetPasswordTokenPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/auth/validate_reset_password_token`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Verify email
     * 
     * @param userId User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restAuthVerifyEmailPut(userId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restAuthVerifyEmailPut(userId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restAuthVerifyEmailPut(userId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restAuthVerifyEmailPut(userId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restAuthVerifyEmailPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('put',`${this.basePath}/auth/${encodeURIComponent(String(userId))}/verify_email`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Verify one time code
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restAuthVerifyOneTimeCodePost(body: VerifyOneTimeCodeRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restAuthVerifyOneTimeCodePost(body: VerifyOneTimeCodeRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restAuthVerifyOneTimeCodePost(body: VerifyOneTimeCodeRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restAuthVerifyOneTimeCodePost(body: VerifyOneTimeCodeRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restAuthVerifyOneTimeCodePost.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/auth/verify_one_time_code`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View the rely list by comments ID
     * 
     * @param commentId Comment ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restCommentReplyIndexPaginable(commentId: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<ListOfCommentReplies>;
    public restCommentReplyIndexPaginable(commentId: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ListOfCommentReplies>>;
    public restCommentReplyIndexPaginable(commentId: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ListOfCommentReplies>>;
    public restCommentReplyIndexPaginable(commentId: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling restCommentReplyIndexPaginable.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ListOfCommentReplies>('get',`${this.basePath}/comment/${encodeURIComponent(String(commentId))}/reply`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add comment reply to comment
     * 
     * @param body 
     * @param commentId Comment ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restCommentReplyPost(body: ReplyCommentRequest, commentId: string, observe?: 'body', reportProgress?: boolean): Observable<ReplyComment>;
    public restCommentReplyPost(body: ReplyCommentRequest, commentId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ReplyComment>>;
    public restCommentReplyPost(body: ReplyCommentRequest, commentId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ReplyComment>>;
    public restCommentReplyPost(body: ReplyCommentRequest, commentId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restCommentReplyPost.');
        }

        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling restCommentReplyPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ReplyComment>('post',`${this.basePath}/comment/${encodeURIComponent(String(commentId))}/reply`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete the comment
     * 
     * @param commentId Comment ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restCommentsDelete(commentId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restCommentsDelete(commentId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restCommentsDelete(commentId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restCommentsDelete(commentId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling restCommentsDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/comment/${encodeURIComponent(String(commentId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove multiple files or folders by entity descriptor id
     * 
     * @param file_descriptor_ids Multiple file descriptor ids
     * @param folder_descriptor_ids Multiple folder descriptor ids
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageBulkDeleteDelete(file_descriptor_ids?: Array<string>, folder_descriptor_ids?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restFileStorageBulkDeleteDelete(file_descriptor_ids?: Array<string>, folder_descriptor_ids?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restFileStorageBulkDeleteDelete(file_descriptor_ids?: Array<string>, folder_descriptor_ids?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restFileStorageBulkDeleteDelete(file_descriptor_ids?: Array<string>, folder_descriptor_ids?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (file_descriptor_ids) {
            file_descriptor_ids.forEach((element) => {
                queryParameters = queryParameters.append('file_descriptor_ids', <any>element);
            })
        }
        if (folder_descriptor_ids) {
            folder_descriptor_ids.forEach((element) => {
                queryParameters = queryParameters.append('folder_descriptor_ids', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/files/bulk_delete`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View file activity log
     * 
     * @param file_descriptor_id FileDescriptorID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param sorting Sorting order param, default is name_asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageFileActivityLogIndex(file_descriptor_id: string, offset?: number, limit?: number, sorting?: string, observe?: 'body', reportProgress?: boolean): Observable<FileActivityLog>;
    public restFileStorageFileActivityLogIndex(file_descriptor_id: string, offset?: number, limit?: number, sorting?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileActivityLog>>;
    public restFileStorageFileActivityLogIndex(file_descriptor_id: string, offset?: number, limit?: number, sorting?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileActivityLog>>;
    public restFileStorageFileActivityLogIndex(file_descriptor_id: string, offset?: number, limit?: number, sorting?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (file_descriptor_id === null || file_descriptor_id === undefined) {
            throw new Error('Required parameter file_descriptor_id was null or undefined when calling restFileStorageFileActivityLogIndex.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sorting !== undefined && sorting !== null) {
            queryParameters = queryParameters.set('sorting', <any>sorting);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FileActivityLog>('get',`${this.basePath}/files/${encodeURIComponent(String(file_descriptor_id))}/activity_log`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove file shareable link
     * 
     * @param file_descriptor_id FileDescriptorID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageFileShareableLinkDelete(file_descriptor_id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restFileStorageFileShareableLinkDelete(file_descriptor_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restFileStorageFileShareableLinkDelete(file_descriptor_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restFileStorageFileShareableLinkDelete(file_descriptor_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (file_descriptor_id === null || file_descriptor_id === undefined) {
            throw new Error('Required parameter file_descriptor_id was null or undefined when calling restFileStorageFileShareableLinkDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/files/${encodeURIComponent(String(file_descriptor_id))}/shareable_link`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Generate shareable link
     * 
     * @param file_descriptor_id FileDescriptorID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageFileShareableLinkPut(file_descriptor_id: string, observe?: 'body', reportProgress?: boolean): Observable<FileDescriptor>;
    public restFileStorageFileShareableLinkPut(file_descriptor_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileDescriptor>>;
    public restFileStorageFileShareableLinkPut(file_descriptor_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileDescriptor>>;
    public restFileStorageFileShareableLinkPut(file_descriptor_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (file_descriptor_id === null || file_descriptor_id === undefined) {
            throw new Error('Required parameter file_descriptor_id was null or undefined when calling restFileStorageFileShareableLinkPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FileDescriptor>('put',`${this.basePath}/files/${encodeURIComponent(String(file_descriptor_id))}/shareable_link`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Share file
     * 
     * @param body 
     * @param file_descriptor_id FileDescriptorID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageFileSharingPut(body: ShareRequest, file_descriptor_id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restFileStorageFileSharingPut(body: ShareRequest, file_descriptor_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restFileStorageFileSharingPut(body: ShareRequest, file_descriptor_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restFileStorageFileSharingPut(body: ShareRequest, file_descriptor_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restFileStorageFileSharingPut.');
        }

        if (file_descriptor_id === null || file_descriptor_id === undefined) {
            throw new Error('Required parameter file_descriptor_id was null or undefined when calling restFileStorageFileSharingPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/files/${encodeURIComponent(String(file_descriptor_id))}/share`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View user files activity log
     * 
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param sorting Sorting order param, default is name_asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageFilesActivityLogIndex(offset?: number, limit?: number, sorting?: string, observe?: 'body', reportProgress?: boolean): Observable<FilesActivityLog>;
    public restFileStorageFilesActivityLogIndex(offset?: number, limit?: number, sorting?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FilesActivityLog>>;
    public restFileStorageFilesActivityLogIndex(offset?: number, limit?: number, sorting?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FilesActivityLog>>;
    public restFileStorageFilesActivityLogIndex(offset?: number, limit?: number, sorting?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sorting !== undefined && sorting !== null) {
            queryParameters = queryParameters.set('sorting', <any>sorting);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FilesActivityLog>('get',`${this.basePath}/files/activity_log`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove file by file descriptor id
     * 
     * @param file_descriptor_id FileDescriptorID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageFilesDelete(file_descriptor_id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restFileStorageFilesDelete(file_descriptor_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restFileStorageFilesDelete(file_descriptor_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restFileStorageFilesDelete(file_descriptor_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (file_descriptor_id === null || file_descriptor_id === undefined) {
            throw new Error('Required parameter file_descriptor_id was null or undefined when calling restFileStorageFilesDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/files/${encodeURIComponent(String(file_descriptor_id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Move and rename file by file descriptor id
     * 
     * @param body 
     * @param file_descriptor_id FileDescriptorID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageFilesPut(body: UpdateFileStorageItemRequest, file_descriptor_id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restFileStorageFilesPut(body: UpdateFileStorageItemRequest, file_descriptor_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restFileStorageFilesPut(body: UpdateFileStorageItemRequest, file_descriptor_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restFileStorageFilesPut(body: UpdateFileStorageItemRequest, file_descriptor_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restFileStorageFilesPut.');
        }

        if (file_descriptor_id === null || file_descriptor_id === undefined) {
            throw new Error('Required parameter file_descriptor_id was null or undefined when calling restFileStorageFilesPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/files/${encodeURIComponent(String(file_descriptor_id))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove folder by folder descriptor id
     * 
     * @param folder_descriptor_id FolderDescriptorID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageFolderDelete(folder_descriptor_id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restFileStorageFolderDelete(folder_descriptor_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restFileStorageFolderDelete(folder_descriptor_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restFileStorageFolderDelete(folder_descriptor_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (folder_descriptor_id === null || folder_descriptor_id === undefined) {
            throw new Error('Required parameter folder_descriptor_id was null or undefined when calling restFileStorageFolderDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/folders/${encodeURIComponent(String(folder_descriptor_id))}/`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View the folders and files list
     * 
     * @param folder_descriptor_id FolderDescriptorID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageFolderGet(folder_descriptor_id: string, observe?: 'body', reportProgress?: boolean): Observable<FoldersResponse>;
    public restFileStorageFolderGet(folder_descriptor_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FoldersResponse>>;
    public restFileStorageFolderGet(folder_descriptor_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FoldersResponse>>;
    public restFileStorageFolderGet(folder_descriptor_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (folder_descriptor_id === null || folder_descriptor_id === undefined) {
            throw new Error('Required parameter folder_descriptor_id was null or undefined when calling restFileStorageFolderGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FoldersResponse>('get',`${this.basePath}/folders/${encodeURIComponent(String(folder_descriptor_id))}/`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageFolderGetRoot(observe?: 'body', reportProgress?: boolean): Observable<FoldersResponse>;
    public restFileStorageFolderGetRoot(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FoldersResponse>>;
    public restFileStorageFolderGetRoot(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FoldersResponse>>;
    public restFileStorageFolderGetRoot(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FoldersResponse>('get',`${this.basePath}/folders`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create folder
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageFolderPost(body: CreateFolderRequest, observe?: 'body', reportProgress?: boolean): Observable<FolderDescriptor>;
    public restFileStorageFolderPost(body: CreateFolderRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FolderDescriptor>>;
    public restFileStorageFolderPost(body: CreateFolderRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FolderDescriptor>>;
    public restFileStorageFolderPost(body: CreateFolderRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restFileStorageFolderPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<FolderDescriptor>('post',`${this.basePath}/folders`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update folder by folder descriptor id
     * 
     * @param body 
     * @param folder_descriptor_id FolderDescriptorID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageFolderPut(body: UpdateFileStorageItemRequest, folder_descriptor_id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restFileStorageFolderPut(body: UpdateFileStorageItemRequest, folder_descriptor_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restFileStorageFolderPut(body: UpdateFileStorageItemRequest, folder_descriptor_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restFileStorageFolderPut(body: UpdateFileStorageItemRequest, folder_descriptor_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restFileStorageFolderPut.');
        }

        if (folder_descriptor_id === null || folder_descriptor_id === undefined) {
            throw new Error('Required parameter folder_descriptor_id was null or undefined when calling restFileStorageFolderPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/folders/${encodeURIComponent(String(folder_descriptor_id))}/`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageFolderSharedGet(observe?: 'body', reportProgress?: boolean): Observable<FoldersResponse>;
    public restFileStorageFolderSharedGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FoldersResponse>>;
    public restFileStorageFolderSharedGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FoldersResponse>>;
    public restFileStorageFolderSharedGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FoldersResponse>('get',`${this.basePath}/folders/shared`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Share folder
     * 
     * @param body 
     * @param folder_descriptor_id FolderDescriptorID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageFolderSharingPut(body: ShareRequest, folder_descriptor_id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restFileStorageFolderSharingPut(body: ShareRequest, folder_descriptor_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restFileStorageFolderSharingPut(body: ShareRequest, folder_descriptor_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restFileStorageFolderSharingPut(body: ShareRequest, folder_descriptor_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restFileStorageFolderSharingPut.');
        }

        if (folder_descriptor_id === null || folder_descriptor_id === undefined) {
            throw new Error('Required parameter folder_descriptor_id was null or undefined when calling restFileStorageFolderSharingPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/folders/${encodeURIComponent(String(folder_descriptor_id))}/share`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Generate file download url
     * 
     * @param file_descriptor_id FileDescriptorID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageGenerateDownloadFileUrlPost(file_descriptor_id: string, observe?: 'body', reportProgress?: boolean): Observable<GenerateDownloadFileUrlResponse>;
    public restFileStorageGenerateDownloadFileUrlPost(file_descriptor_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenerateDownloadFileUrlResponse>>;
    public restFileStorageGenerateDownloadFileUrlPost(file_descriptor_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenerateDownloadFileUrlResponse>>;
    public restFileStorageGenerateDownloadFileUrlPost(file_descriptor_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (file_descriptor_id === null || file_descriptor_id === undefined) {
            throw new Error('Required parameter file_descriptor_id was null or undefined when calling restFileStorageGenerateDownloadFileUrlPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<GenerateDownloadFileUrlResponse>('post',`${this.basePath}/files/${encodeURIComponent(String(file_descriptor_id))}/download`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create S3 file link
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageGenerateFileUrlPost(body: GenerateFileRequest, observe?: 'body', reportProgress?: boolean): Observable<GenerateFileResponse>;
    public restFileStorageGenerateFileUrlPost(body: GenerateFileRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenerateFileResponse>>;
    public restFileStorageGenerateFileUrlPost(body: GenerateFileRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenerateFileResponse>>;
    public restFileStorageGenerateFileUrlPost(body: GenerateFileRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restFileStorageGenerateFileUrlPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<GenerateFileResponse>('post',`${this.basePath}/files/generate`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restFileStorageSizeGet(observe?: 'body', reportProgress?: boolean): Observable<FileSizeResponse>;
    public restFileStorageSizeGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileSizeResponse>>;
    public restFileStorageSizeGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileSizeResponse>>;
    public restFileStorageSizeGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FileSizeResponse>('get',`${this.basePath}/files/size`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param params Stringified json data of search request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restMapCovidGet(params: string, observe?: 'body', reportProgress?: boolean): Observable<CovidMapData>;
    public restMapCovidGet(params: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CovidMapData>>;
    public restMapCovidGet(params: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CovidMapData>>;
    public restMapCovidGet(params: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (params === null || params === undefined) {
            throw new Error('Required parameter params was null or undefined when calling restMapCovidGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (params !== undefined && params !== null) {
            queryParameters = queryParameters.set('params', <any>params);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<CovidMapData>('get',`${this.basePath}/map/layer/covid_map`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param params Stringified json data of search request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restMapCovidVaccinationsGet(params: string, observe?: 'body', reportProgress?: boolean): Observable<CovidVaccinationsMapData>;
    public restMapCovidVaccinationsGet(params: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CovidVaccinationsMapData>>;
    public restMapCovidVaccinationsGet(params: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CovidVaccinationsMapData>>;
    public restMapCovidVaccinationsGet(params: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (params === null || params === undefined) {
            throw new Error('Required parameter params was null or undefined when calling restMapCovidVaccinationsGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (params !== undefined && params !== null) {
            queryParameters = queryParameters.set('params', <any>params);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<CovidVaccinationsMapData>('get',`${this.basePath}/map/layer/covid_vaccinations_map`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param params Stringified json data of search request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restMapStatisticsGet(params: string, observe?: 'body', reportProgress?: boolean): Observable<Statistics>;
    public restMapStatisticsGet(params: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Statistics>>;
    public restMapStatisticsGet(params: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Statistics>>;
    public restMapStatisticsGet(params: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (params === null || params === undefined) {
            throw new Error('Required parameter params was null or undefined when calling restMapStatisticsGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (params !== undefined && params !== null) {
            queryParameters = queryParameters.set('params', <any>params);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Statistics>('get',`${this.basePath}/statistics`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete profile from the block list
     * 
     * @param userId User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restProfileBlockDelete(userId: string, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse201>;
    public restProfileBlockDelete(userId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse201>>;
    public restProfileBlockDelete(userId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse201>>;
    public restProfileBlockDelete(userId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restProfileBlockDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse201>('delete',`${this.basePath}/profile/${encodeURIComponent(String(userId))}/block`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches data of all profile that user blocked
     * 
     * @param userId User ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restProfileBlockGet(userId: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<ListOfExtendedUsers>;
    public restProfileBlockGet(userId: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ListOfExtendedUsers>>;
    public restProfileBlockGet(userId: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ListOfExtendedUsers>>;
    public restProfileBlockGet(userId: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restProfileBlockGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ListOfExtendedUsers>('get',`${this.basePath}/profile/${encodeURIComponent(String(userId))}/blocked`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add profile to the blocked list
     * 
     * @param userId User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restProfileBlockPost(userId: string, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse201>;
    public restProfileBlockPost(userId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse201>>;
    public restProfileBlockPost(userId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse201>>;
    public restProfileBlockPost(userId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restProfileBlockPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse201>('post',`${this.basePath}/profile/${encodeURIComponent(String(userId))}/block`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches data of requested search aggregation items
     * 
     * @param params Stringifyied json data of search aggregation request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSearchAggregationsGet(params?: string, observe?: 'body', reportProgress?: boolean): Observable<SearchAggregationResponse>;
    public restSearchAggregationsGet(params?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SearchAggregationResponse>>;
    public restSearchAggregationsGet(params?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SearchAggregationResponse>>;
    public restSearchAggregationsGet(params?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (params !== undefined && params !== null) {
            queryParameters = queryParameters.set('params', <any>params);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SearchAggregationResponse>('get',`${this.basePath}/search/aggregations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches metadata of the attributes for search
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSearchAttributesIndexGet(observe?: 'body', reportProgress?: boolean): Observable<SearchAttributesResponse>;
    public restSearchAttributesIndexGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SearchAttributesResponse>>;
    public restSearchAttributesIndexGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SearchAttributesResponse>>;
    public restSearchAttributesIndexGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SearchAttributesResponse>('get',`${this.basePath}/search/attributes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches data of requested search items
     * 
     * @param params Stringifyied json data of search request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSearchResultsGet(params?: string, observe?: 'body', reportProgress?: boolean): Observable<SearchResponse>;
    public restSearchResultsGet(params?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SearchResponse>>;
    public restSearchResultsGet(params?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SearchResponse>>;
    public restSearchResultsGet(params?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (params !== undefined && params !== null) {
            queryParameters = queryParameters.set('params', <any>params);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SearchResponse>('get',`${this.basePath}/search/results`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Suggestion for autocomplete request in response
     * 
     * @param q Query.
     * @param attributeName Name of the attribute.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSearchSuggestGet(q: string, attributeName: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public restSearchSuggestGet(q: string, attributeName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public restSearchSuggestGet(q: string, attributeName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public restSearchSuggestGet(q: string, attributeName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling restSearchSuggestGet.');
        }

        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling restSearchSuggestGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (q !== undefined && q !== null) {
            queryParameters = queryParameters.set('q', <any>q);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<string>>('get',`${this.basePath}/search/suggest/${encodeURIComponent(String(attributeName))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove community
     * 
     * @param communityId Community ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunitiesDelete(communityId: string, observe?: 'body', reportProgress?: boolean): Observable<EmptyResponse>;
    public restSocialCommunitiesDelete(communityId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyResponse>>;
    public restSocialCommunitiesDelete(communityId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyResponse>>;
    public restSocialCommunitiesDelete(communityId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (communityId === null || communityId === undefined) {
            throw new Error('Required parameter communityId was null or undefined when calling restSocialCommunitiesDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyResponse>('delete',`${this.basePath}/social/community/${encodeURIComponent(String(communityId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View community
     * 
     * @param communityId Community ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunitiesGet(communityId: string, observe?: 'body', reportProgress?: boolean): Observable<Community>;
    public restSocialCommunitiesGet(communityId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Community>>;
    public restSocialCommunitiesGet(communityId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Community>>;
    public restSocialCommunitiesGet(communityId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (communityId === null || communityId === undefined) {
            throw new Error('Required parameter communityId was null or undefined when calling restSocialCommunitiesGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Community>('get',`${this.basePath}/social/community/${encodeURIComponent(String(communityId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View all invitations to join communities
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunitiesGotInvitationsIndex(observe?: 'body', reportProgress?: boolean): Observable<PaginatablePendingUserInvolvementsInCommunities>;
    public restSocialCommunitiesGotInvitationsIndex(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PaginatablePendingUserInvolvementsInCommunities>>;
    public restSocialCommunitiesGotInvitationsIndex(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PaginatablePendingUserInvolvementsInCommunities>>;
    public restSocialCommunitiesGotInvitationsIndex(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<PaginatablePendingUserInvolvementsInCommunities>('get',`${this.basePath}/social/communities/invitations`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View all communities for current user
     * 
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunitiesIndex(offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<Communities>;
    public restSocialCommunitiesIndex(offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Communities>>;
    public restSocialCommunitiesIndex(offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Communities>>;
    public restSocialCommunitiesIndex(offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Communities>('get',`${this.basePath}/social/communities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get counters for user communities social involvement
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunitiesInvolvementCountersGet(observe?: 'body', reportProgress?: boolean): Observable<RequestCounters>;
    public restSocialCommunitiesInvolvementCountersGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RequestCounters>>;
    public restSocialCommunitiesInvolvementCountersGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RequestCounters>>;
    public restSocialCommunitiesInvolvementCountersGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<RequestCounters>('get',`${this.basePath}/social/communities/involvement_counters`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new community
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunitiesPost(body: CreateCommunityRequest, observe?: 'body', reportProgress?: boolean): Observable<Community>;
    public restSocialCommunitiesPost(body: CreateCommunityRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Community>>;
    public restSocialCommunitiesPost(body: CreateCommunityRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Community>>;
    public restSocialCommunitiesPost(body: CreateCommunityRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restSocialCommunitiesPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Community>('post',`${this.basePath}/social/communities`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit community
     * 
     * @param body 
     * @param communityId Community ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunitiesPut(body: UpdateCommunityRequest, communityId: string, observe?: 'body', reportProgress?: boolean): Observable<Community>;
    public restSocialCommunitiesPut(body: UpdateCommunityRequest, communityId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Community>>;
    public restSocialCommunitiesPut(body: UpdateCommunityRequest, communityId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Community>>;
    public restSocialCommunitiesPut(body: UpdateCommunityRequest, communityId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restSocialCommunitiesPut.');
        }

        if (communityId === null || communityId === undefined) {
            throw new Error('Required parameter communityId was null or undefined when calling restSocialCommunitiesPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Community>('put',`${this.basePath}/social/community/${encodeURIComponent(String(communityId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View all sent requests to join communities
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunitiesSentRequestsIndex(observe?: 'body', reportProgress?: boolean): Observable<PaginatablePendingUserInvolvementsInCommunities>;
    public restSocialCommunitiesSentRequestsIndex(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PaginatablePendingUserInvolvementsInCommunities>>;
    public restSocialCommunitiesSentRequestsIndex(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PaginatablePendingUserInvolvementsInCommunities>>;
    public restSocialCommunitiesSentRequestsIndex(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<PaginatablePendingUserInvolvementsInCommunities>('get',`${this.basePath}/social/communities/sent_requests`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetch all sent invitations by user for a specific community
     * 
     * @param communityId Community ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunityInvitesIndex(communityId: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<PendingUserInvolvements>;
    public restSocialCommunityInvitesIndex(communityId: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PendingUserInvolvements>>;
    public restSocialCommunityInvitesIndex(communityId: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PendingUserInvolvements>>;
    public restSocialCommunityInvitesIndex(communityId: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (communityId === null || communityId === undefined) {
            throw new Error('Required parameter communityId was null or undefined when calling restSocialCommunityInvitesIndex.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<PendingUserInvolvements>('get',`${this.basePath}/social/community/${encodeURIComponent(String(communityId))}/sent_invitations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get counters for communities centric user involvement
     * 
     * @param communityId Community ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunityInvolvementCountersGet(communityId: string, observe?: 'body', reportProgress?: boolean): Observable<RequestCountersBasic>;
    public restSocialCommunityInvolvementCountersGet(communityId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RequestCountersBasic>>;
    public restSocialCommunityInvolvementCountersGet(communityId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RequestCountersBasic>>;
    public restSocialCommunityInvolvementCountersGet(communityId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (communityId === null || communityId === undefined) {
            throw new Error('Required parameter communityId was null or undefined when calling restSocialCommunityInvolvementCountersGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<RequestCountersBasic>('get',`${this.basePath}/social/community/${encodeURIComponent(String(communityId))}/involvement_counters`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetch all community leaders
     * 
     * @param communityId Community ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunityLeadersIndex(communityId: string, observe?: 'body', reportProgress?: boolean): Observable<ListOfBasicUsers>;
    public restSocialCommunityLeadersIndex(communityId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ListOfBasicUsers>>;
    public restSocialCommunityLeadersIndex(communityId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ListOfBasicUsers>>;
    public restSocialCommunityLeadersIndex(communityId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (communityId === null || communityId === undefined) {
            throw new Error('Required parameter communityId was null or undefined when calling restSocialCommunityLeadersIndex.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ListOfBasicUsers>('get',`${this.basePath}/social/community/${encodeURIComponent(String(communityId))}/leaders`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Leave the community, remove a user from members
     * 
     * @param communityId Community ID
     * @param userId User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunityMembersDelete(communityId: string, userId: string, observe?: 'body', reportProgress?: boolean): Observable<EmptyResponse>;
    public restSocialCommunityMembersDelete(communityId: string, userId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyResponse>>;
    public restSocialCommunityMembersDelete(communityId: string, userId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyResponse>>;
    public restSocialCommunityMembersDelete(communityId: string, userId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (communityId === null || communityId === undefined) {
            throw new Error('Required parameter communityId was null or undefined when calling restSocialCommunityMembersDelete.');
        }

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restSocialCommunityMembersDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyResponse>('delete',`${this.basePath}/social/community/${encodeURIComponent(String(communityId))}/member/${encodeURIComponent(String(userId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View members list
     * 
     * @param communityId Community ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunityMembersIndex(communityId: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<ListOfBasicUsers>;
    public restSocialCommunityMembersIndex(communityId: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ListOfBasicUsers>>;
    public restSocialCommunityMembersIndex(communityId: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ListOfBasicUsers>>;
    public restSocialCommunityMembersIndex(communityId: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (communityId === null || communityId === undefined) {
            throw new Error('Required parameter communityId was null or undefined when calling restSocialCommunityMembersIndex.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ListOfBasicUsers>('get',`${this.basePath}/social/community/${encodeURIComponent(String(communityId))}/members`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Invite a user to the community, join the community, send request to join
     * 
     * @param body 
     * @param communityId Community ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunityMembersPost(body: UserIdRequest, communityId: string, observe?: 'body', reportProgress?: boolean): Observable<EmptyResponse>;
    public restSocialCommunityMembersPost(body: UserIdRequest, communityId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyResponse>>;
    public restSocialCommunityMembersPost(body: UserIdRequest, communityId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyResponse>>;
    public restSocialCommunityMembersPost(body: UserIdRequest, communityId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restSocialCommunityMembersPost.');
        }

        if (communityId === null || communityId === undefined) {
            throw new Error('Required parameter communityId was null or undefined when calling restSocialCommunityMembersPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<EmptyResponse>('post',`${this.basePath}/social/community/${encodeURIComponent(String(communityId))}/members`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Community lead accepts join request to become the community member, or invited profile accepts lead&#x27;s invitation
     * 
     * @param body 
     * @param communityId Community ID
     * @param userId User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunityMembersPut(body: CommunityInviteOrDeclineRequest, communityId: string, userId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restSocialCommunityMembersPut(body: CommunityInviteOrDeclineRequest, communityId: string, userId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restSocialCommunityMembersPut(body: CommunityInviteOrDeclineRequest, communityId: string, userId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restSocialCommunityMembersPut(body: CommunityInviteOrDeclineRequest, communityId: string, userId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restSocialCommunityMembersPut.');
        }

        if (communityId === null || communityId === undefined) {
            throw new Error('Required parameter communityId was null or undefined when calling restSocialCommunityMembersPut.');
        }

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restSocialCommunityMembersPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/social/community/${encodeURIComponent(String(communityId))}/member/${encodeURIComponent(String(userId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View posts list
     * 
     * @param communityId Community ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunityPostsIndex(communityId: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<Posts>;
    public restSocialCommunityPostsIndex(communityId: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Posts>>;
    public restSocialCommunityPostsIndex(communityId: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Posts>>;
    public restSocialCommunityPostsIndex(communityId: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (communityId === null || communityId === undefined) {
            throw new Error('Required parameter communityId was null or undefined when calling restSocialCommunityPostsIndex.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Posts>('get',`${this.basePath}/social/community/${encodeURIComponent(String(communityId))}/posts`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View projects list
     * 
     * @param communityId Community ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunityProjectsIndex(communityId: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<Projects>;
    public restSocialCommunityProjectsIndex(communityId: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Projects>>;
    public restSocialCommunityProjectsIndex(communityId: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Projects>>;
    public restSocialCommunityProjectsIndex(communityId: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (communityId === null || communityId === undefined) {
            throw new Error('Required parameter communityId was null or undefined when calling restSocialCommunityProjectsIndex.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Projects>('get',`${this.basePath}/social/community/${encodeURIComponent(String(communityId))}/projects`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetch all user requests to join a specific community
     * 
     * @param communityId Community ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialCommunityRequestsIndex(communityId: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<PendingUserInvolvements>;
    public restSocialCommunityRequestsIndex(communityId: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PendingUserInvolvements>>;
    public restSocialCommunityRequestsIndex(communityId: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PendingUserInvolvements>>;
    public restSocialCommunityRequestsIndex(communityId: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (communityId === null || communityId === undefined) {
            throw new Error('Required parameter communityId was null or undefined when calling restSocialCommunityRequestsIndex.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<PendingUserInvolvements>('get',`${this.basePath}/social/community/${encodeURIComponent(String(communityId))}/requests`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Resets the title of the conversation
     * 
     * @param conversationId Conversation ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialConversationTitleDelete(conversationId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restSocialConversationTitleDelete(conversationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restSocialConversationTitleDelete(conversationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restSocialConversationTitleDelete(conversationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (conversationId === null || conversationId === undefined) {
            throw new Error('Required parameter conversationId was null or undefined when calling restSocialConversationTitleDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/social/conversations/${encodeURIComponent(String(conversationId))}/title`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the title of the conversation
     * 
     * @param body 
     * @param conversationId Conversation ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialConversationTitlePut(body: UpdateConversationTitleRequest, conversationId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restSocialConversationTitlePut(body: UpdateConversationTitleRequest, conversationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restSocialConversationTitlePut(body: UpdateConversationTitleRequest, conversationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restSocialConversationTitlePut(body: UpdateConversationTitleRequest, conversationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restSocialConversationTitlePut.');
        }

        if (conversationId === null || conversationId === undefined) {
            throw new Error('Required parameter conversationId was null or undefined when calling restSocialConversationTitlePut.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/social/conversations/${encodeURIComponent(String(conversationId))}/title`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a conversation
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialConversationsPost(body: CreateConversationRequest, observe?: 'body', reportProgress?: boolean): Observable<Conversation>;
    public restSocialConversationsPost(body: CreateConversationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Conversation>>;
    public restSocialConversationsPost(body: CreateConversationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Conversation>>;
    public restSocialConversationsPost(body: CreateConversationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restSocialConversationsPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Conversation>('post',`${this.basePath}/social/conversations`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Contact site owners
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialFeedbackPost(body: AddFeedbackRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restSocialFeedbackPost(body: AddFeedbackRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restSocialFeedbackPost(body: AddFeedbackRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restSocialFeedbackPost(body: AddFeedbackRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restSocialFeedbackPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/feedback`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View comments list
     * 
     * @param postId POST ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param replyLimit The numbers of comment reply items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialPostCommentsIndexList(postId: string, offset?: number, limit?: number, replyLimit?: number, observe?: 'body', reportProgress?: boolean): Observable<ListOfRootComments>;
    public restSocialPostCommentsIndexList(postId: string, offset?: number, limit?: number, replyLimit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ListOfRootComments>>;
    public restSocialPostCommentsIndexList(postId: string, offset?: number, limit?: number, replyLimit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ListOfRootComments>>;
    public restSocialPostCommentsIndexList(postId: string, offset?: number, limit?: number, replyLimit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (postId === null || postId === undefined) {
            throw new Error('Required parameter postId was null or undefined when calling restSocialPostCommentsIndexList.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (replyLimit !== undefined && replyLimit !== null) {
            queryParameters = queryParameters.set('replyLimit', <any>replyLimit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ListOfRootComments>('get',`${this.basePath}/social/post/${encodeURIComponent(String(postId))}/comments_list`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add a comment
     * 
     * @param body 
     * @param postId POST ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialPostCommentsPost(body: CreateCommentRequest, postId: string, observe?: 'body', reportProgress?: boolean): Observable<RootComment>;
    public restSocialPostCommentsPost(body: CreateCommentRequest, postId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RootComment>>;
    public restSocialPostCommentsPost(body: CreateCommentRequest, postId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RootComment>>;
    public restSocialPostCommentsPost(body: CreateCommentRequest, postId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restSocialPostCommentsPost.');
        }

        if (postId === null || postId === undefined) {
            throw new Error('Required parameter postId was null or undefined when calling restSocialPostCommentsPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<RootComment>('post',`${this.basePath}/social/post/${encodeURIComponent(String(postId))}/comments`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove post
     * 
     * @param postId POST ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialPostsDelete(postId: string, observe?: 'body', reportProgress?: boolean): Observable<EmptyResponse>;
    public restSocialPostsDelete(postId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyResponse>>;
    public restSocialPostsDelete(postId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyResponse>>;
    public restSocialPostsDelete(postId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (postId === null || postId === undefined) {
            throw new Error('Required parameter postId was null or undefined when calling restSocialPostsDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyResponse>('delete',`${this.basePath}/social/post/${encodeURIComponent(String(postId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View post
     * 
     * @param postId POST ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialPostsGet(postId: string, observe?: 'body', reportProgress?: boolean): Observable<Post>;
    public restSocialPostsGet(postId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Post>>;
    public restSocialPostsGet(postId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Post>>;
    public restSocialPostsGet(postId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (postId === null || postId === undefined) {
            throw new Error('Required parameter postId was null or undefined when calling restSocialPostsGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Post>('get',`${this.basePath}/social/post/${encodeURIComponent(String(postId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new post
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialPostsPost(body: CreatePostRequest, observe?: 'body', reportProgress?: boolean): Observable<Post>;
    public restSocialPostsPost(body: CreatePostRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Post>>;
    public restSocialPostsPost(body: CreatePostRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Post>>;
    public restSocialPostsPost(body: CreatePostRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restSocialPostsPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Post>('post',`${this.basePath}/social/posts`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit post
     * 
     * @param body 
     * @param postId POST ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialPostsPut(body: UpdatePostRequest, postId: string, observe?: 'body', reportProgress?: boolean): Observable<Post>;
    public restSocialPostsPut(body: UpdatePostRequest, postId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Post>>;
    public restSocialPostsPut(body: UpdatePostRequest, postId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Post>>;
    public restSocialPostsPut(body: UpdatePostRequest, postId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restSocialPostsPut.');
        }

        if (postId === null || postId === undefined) {
            throw new Error('Required parameter postId was null or undefined when calling restSocialPostsPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Post>('put',`${this.basePath}/social/post/${encodeURIComponent(String(postId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Profile connections counters by status
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProfileConnectionsCounters(observe?: 'body', reportProgress?: boolean): Observable<RequestCounters>;
    public restSocialProfileConnectionsCounters(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RequestCounters>>;
    public restSocialProfileConnectionsCounters(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RequestCounters>>;
    public restSocialProfileConnectionsCounters(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<RequestCounters>('get',`${this.basePath}/social/profile/connections_counters`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove connection by account id
     * 
     * @param userId User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProfileConnectionsDelete(userId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restSocialProfileConnectionsDelete(userId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restSocialProfileConnectionsDelete(userId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restSocialProfileConnectionsDelete(userId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restSocialProfileConnectionsDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/social/profile/connection/${encodeURIComponent(String(userId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetching a foreign user&#x27;s connection requests (Admin only)
     * 
     * @param userId User ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param sorting Sorting order param, default is name_asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProfileConnectionsIndexForeignVerified(userId: string, offset?: number, limit?: number, sorting?: string, observe?: 'body', reportProgress?: boolean): Observable<Connections>;
    public restSocialProfileConnectionsIndexForeignVerified(userId: string, offset?: number, limit?: number, sorting?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Connections>>;
    public restSocialProfileConnectionsIndexForeignVerified(userId: string, offset?: number, limit?: number, sorting?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Connections>>;
    public restSocialProfileConnectionsIndexForeignVerified(userId: string, offset?: number, limit?: number, sorting?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restSocialProfileConnectionsIndexForeignVerified.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sorting !== undefined && sorting !== null) {
            queryParameters = queryParameters.set('sorting', <any>sorting);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Connections>('get',`${this.basePath}/social/profile/verified_connections/${encodeURIComponent(String(userId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetching all verified connections for current user
     * 
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param sorting Sorting order param, default is name_asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProfileConnectionsIndexVerified(offset?: number, limit?: number, sorting?: string, observe?: 'body', reportProgress?: boolean): Observable<Connections>;
    public restSocialProfileConnectionsIndexVerified(offset?: number, limit?: number, sorting?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Connections>>;
    public restSocialProfileConnectionsIndexVerified(offset?: number, limit?: number, sorting?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Connections>>;
    public restSocialProfileConnectionsIndexVerified(offset?: number, limit?: number, sorting?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sorting !== undefined && sorting !== null) {
            queryParameters = queryParameters.set('sorting', <any>sorting);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Connections>('get',`${this.basePath}/social/profile/verified_connections`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add connection to current user by account id
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProfileConnectionsPost(body: Body, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restSocialProfileConnectionsPost(body: Body, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restSocialProfileConnectionsPost(body: Body, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restSocialProfileConnectionsPost(body: Body, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restSocialProfileConnectionsPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/social/profile/connections`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Accept or decline connection by account id
     * 
     * @param body 
     * @param userId User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProfileConnectionsPut(body: ConnectionRequestStatus, userId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restSocialProfileConnectionsPut(body: ConnectionRequestStatus, userId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restSocialProfileConnectionsPut(body: ConnectionRequestStatus, userId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restSocialProfileConnectionsPut(body: ConnectionRequestStatus, userId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restSocialProfileConnectionsPut.');
        }

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restSocialProfileConnectionsPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/social/profile/connection/${encodeURIComponent(String(userId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetching all sent requests by current user
     * 
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param sorting Sorting order param, default is name_asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProfileConnectionsRequestsIndex(offset?: number, limit?: number, sorting?: string, observe?: 'body', reportProgress?: boolean): Observable<Connections>;
    public restSocialProfileConnectionsRequestsIndex(offset?: number, limit?: number, sorting?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Connections>>;
    public restSocialProfileConnectionsRequestsIndex(offset?: number, limit?: number, sorting?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Connections>>;
    public restSocialProfileConnectionsRequestsIndex(offset?: number, limit?: number, sorting?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sorting !== undefined && sorting !== null) {
            queryParameters = queryParameters.set('sorting', <any>sorting);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Connections>('get',`${this.basePath}/social/profile/sent_connections_requests`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetching a foreign user&#x27;s sent connection requests (Admin only)
     * 
     * @param userId User ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProfileConnectionsRequestsIndexForeign(userId: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<Connections>;
    public restSocialProfileConnectionsRequestsIndexForeign(userId: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Connections>>;
    public restSocialProfileConnectionsRequestsIndexForeign(userId: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Connections>>;
    public restSocialProfileConnectionsRequestsIndexForeign(userId: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restSocialProfileConnectionsRequestsIndexForeign.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Connections>('get',`${this.basePath}/social/profile/sent_connections_requests/${encodeURIComponent(String(userId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetching a foreign user&#x27;s connection requests received (Admin only)
     * 
     * @param userId User ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProfileConnectionsRequestsIndexForeignReceived(userId: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<Connections>;
    public restSocialProfileConnectionsRequestsIndexForeignReceived(userId: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Connections>>;
    public restSocialProfileConnectionsRequestsIndexForeignReceived(userId: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Connections>>;
    public restSocialProfileConnectionsRequestsIndexForeignReceived(userId: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restSocialProfileConnectionsRequestsIndexForeignReceived.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Connections>('get',`${this.basePath}/social/profile/received_connections_requests/${encodeURIComponent(String(userId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetching all received requests for current user
     * 
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param sorting Sorting order param, default is name_asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProfileConnectionsRequestsIndexReceived(offset?: number, limit?: number, sorting?: string, observe?: 'body', reportProgress?: boolean): Observable<Connections>;
    public restSocialProfileConnectionsRequestsIndexReceived(offset?: number, limit?: number, sorting?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Connections>>;
    public restSocialProfileConnectionsRequestsIndexReceived(offset?: number, limit?: number, sorting?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Connections>>;
    public restSocialProfileConnectionsRequestsIndexReceived(offset?: number, limit?: number, sorting?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sorting !== undefined && sorting !== null) {
            queryParameters = queryParameters.set('sorting', <any>sorting);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Connections>('get',`${this.basePath}/social/profile/received_connections_requests`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Logs the current user into messaging external service and returns access token for client SDK
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProfileMessagingAccessPost(observe?: 'body', reportProgress?: boolean): Observable<MessagingAccessToken>;
    public restSocialProfileMessagingAccessPost(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MessagingAccessToken>>;
    public restSocialProfileMessagingAccessPost(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MessagingAccessToken>>;
    public restSocialProfileMessagingAccessPost(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<MessagingAccessToken>('post',`${this.basePath}/social/profile/messaging/access`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns data of current&#x27;s profile individual messaging channel for system notifications
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProfileMessagingNotifyChannelGet(observe?: 'body', reportProgress?: boolean): Observable<MessagingChannelBasic>;
    public restSocialProfileMessagingNotifyChannelGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MessagingChannelBasic>>;
    public restSocialProfileMessagingNotifyChannelGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MessagingChannelBasic>>;
    public restSocialProfileMessagingNotifyChannelGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<MessagingChannelBasic>('get',`${this.basePath}/social/profile/messaging/notify_channel`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetch all posts by userId
     * 
     * @param userId User ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProfilePostsIndex(userId: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<Posts>;
    public restSocialProfilePostsIndex(userId: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Posts>>;
    public restSocialProfilePostsIndex(userId: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Posts>>;
    public restSocialProfilePostsIndex(userId: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restSocialProfilePostsIndex.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Posts>('get',`${this.basePath}/social/profile/${encodeURIComponent(String(userId))}/posts`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetch all project leaders
     * 
     * @param projectId Project ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectLeadersIndex(projectId: string, observe?: 'body', reportProgress?: boolean): Observable<ListOfBasicUsers>;
    public restSocialProjectLeadersIndex(projectId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ListOfBasicUsers>>;
    public restSocialProjectLeadersIndex(projectId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ListOfBasicUsers>>;
    public restSocialProjectLeadersIndex(projectId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling restSocialProjectLeadersIndex.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ListOfBasicUsers>('get',`${this.basePath}/social/project/${encodeURIComponent(String(projectId))}/leaders`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View the project invited and pending owners list
     * 
     * @param projectId Project ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectLeadersIndexPending(projectId: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<PendingUserInvolvements>;
    public restSocialProjectLeadersIndexPending(projectId: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PendingUserInvolvements>>;
    public restSocialProjectLeadersIndexPending(projectId: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PendingUserInvolvements>>;
    public restSocialProjectLeadersIndexPending(projectId: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling restSocialProjectLeadersIndexPending.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<PendingUserInvolvements>('get',`${this.basePath}/social/project/${encodeURIComponent(String(projectId))}/owners/invitations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Leave the project, remove a user from members
     * 
     * @param projectId Project ID
     * @param userId User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectMembersDelete(projectId: string, userId: string, observe?: 'body', reportProgress?: boolean): Observable<EmptyResponse>;
    public restSocialProjectMembersDelete(projectId: string, userId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyResponse>>;
    public restSocialProjectMembersDelete(projectId: string, userId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyResponse>>;
    public restSocialProjectMembersDelete(projectId: string, userId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling restSocialProjectMembersDelete.');
        }

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restSocialProjectMembersDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyResponse>('delete',`${this.basePath}/social/project/${encodeURIComponent(String(projectId))}/member/${encodeURIComponent(String(userId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View members list
     * 
     * @param projectId Project ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectMembersIndex(projectId: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<BasicUsersAsList>;
    public restSocialProjectMembersIndex(projectId: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BasicUsersAsList>>;
    public restSocialProjectMembersIndex(projectId: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BasicUsersAsList>>;
    public restSocialProjectMembersIndex(projectId: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling restSocialProjectMembersIndex.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<BasicUsersAsList>('get',`${this.basePath}/social/project/${encodeURIComponent(String(projectId))}/members`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View the project pending invited participants list
     * 
     * @param projectId Project ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectMembersIndexPending(projectId: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<PendingUserInvolvements>;
    public restSocialProjectMembersIndexPending(projectId: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PendingUserInvolvements>>;
    public restSocialProjectMembersIndexPending(projectId: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PendingUserInvolvements>>;
    public restSocialProjectMembersIndexPending(projectId: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling restSocialProjectMembersIndexPending.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<PendingUserInvolvements>('get',`${this.basePath}/social/project/${encodeURIComponent(String(projectId))}/participants/invitations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View the project pending requested participants list
     * 
     * @param projectId Project ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectMembersIndexRequests(projectId: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<PendingUserInvolvements>;
    public restSocialProjectMembersIndexRequests(projectId: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PendingUserInvolvements>>;
    public restSocialProjectMembersIndexRequests(projectId: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PendingUserInvolvements>>;
    public restSocialProjectMembersIndexRequests(projectId: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling restSocialProjectMembersIndexRequests.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<PendingUserInvolvements>('get',`${this.basePath}/social/project/${encodeURIComponent(String(projectId))}/participants/requests`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View the project pending invitation and requests counters
     * 
     * @param projectId Project ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectMembersInvolvementCounters(projectId: string, observe?: 'body', reportProgress?: boolean): Observable<RequestCountersBasic>;
    public restSocialProjectMembersInvolvementCounters(projectId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RequestCountersBasic>>;
    public restSocialProjectMembersInvolvementCounters(projectId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RequestCountersBasic>>;
    public restSocialProjectMembersInvolvementCounters(projectId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling restSocialProjectMembersInvolvementCounters.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<RequestCountersBasic>('get',`${this.basePath}/social/project/${encodeURIComponent(String(projectId))}/participants/involvement_counters`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Invite a user to the project, join the project, send request to join
     * 
     * @param body 
     * @param projectId Project ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectMembersPost(body: UserIdRequest, projectId: string, observe?: 'body', reportProgress?: boolean): Observable<EmptyResponse>;
    public restSocialProjectMembersPost(body: UserIdRequest, projectId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyResponse>>;
    public restSocialProjectMembersPost(body: UserIdRequest, projectId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyResponse>>;
    public restSocialProjectMembersPost(body: UserIdRequest, projectId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restSocialProjectMembersPost.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling restSocialProjectMembersPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<EmptyResponse>('post',`${this.basePath}/social/project/${encodeURIComponent(String(projectId))}/members`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * User accept or reject invitation to become the project member
     * 
     * @param body 
     * @param projectId Project ID
     * @param userId User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectMembersPut(body: ProjectInviteOrDeclineRequest, projectId: string, userId: string, observe?: 'body', reportProgress?: boolean): Observable<EmptyResponse>;
    public restSocialProjectMembersPut(body: ProjectInviteOrDeclineRequest, projectId: string, userId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyResponse>>;
    public restSocialProjectMembersPut(body: ProjectInviteOrDeclineRequest, projectId: string, userId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyResponse>>;
    public restSocialProjectMembersPut(body: ProjectInviteOrDeclineRequest, projectId: string, userId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restSocialProjectMembersPut.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling restSocialProjectMembersPut.');
        }

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restSocialProjectMembersPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<EmptyResponse>('put',`${this.basePath}/social/project/${encodeURIComponent(String(projectId))}/member/${encodeURIComponent(String(userId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View posts list
     * 
     * @param projectId Project ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectPostsIndex(projectId: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<Posts>;
    public restSocialProjectPostsIndex(projectId: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Posts>>;
    public restSocialProjectPostsIndex(projectId: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Posts>>;
    public restSocialProjectPostsIndex(projectId: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling restSocialProjectPostsIndex.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Posts>('get',`${this.basePath}/social/project/${encodeURIComponent(String(projectId))}/posts`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Reject/remove a users request to join a project from requests list
     * 
     * @param projectId Project ID
     * @param userId User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectRequestsDelete(projectId: string, userId: string, observe?: 'body', reportProgress?: boolean): Observable<EmptyResponse>;
    public restSocialProjectRequestsDelete(projectId: string, userId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyResponse>>;
    public restSocialProjectRequestsDelete(projectId: string, userId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyResponse>>;
    public restSocialProjectRequestsDelete(projectId: string, userId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling restSocialProjectRequestsDelete.');
        }

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restSocialProjectRequestsDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyResponse>('delete',`${this.basePath}/social/project/${encodeURIComponent(String(projectId))}/participants/request/${encodeURIComponent(String(userId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove project
     * 
     * @param projectId Project ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectsDelete(projectId: string, observe?: 'body', reportProgress?: boolean): Observable<EmptyResponse>;
    public restSocialProjectsDelete(projectId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyResponse>>;
    public restSocialProjectsDelete(projectId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyResponse>>;
    public restSocialProjectsDelete(projectId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling restSocialProjectsDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyResponse>('delete',`${this.basePath}/social/project/${encodeURIComponent(String(projectId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View project
     * 
     * @param projectId Project ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectsGet(projectId: string, observe?: 'body', reportProgress?: boolean): Observable<Project>;
    public restSocialProjectsGet(projectId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Project>>;
    public restSocialProjectsGet(projectId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Project>>;
    public restSocialProjectsGet(projectId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling restSocialProjectsGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Project>('get',`${this.basePath}/social/project/${encodeURIComponent(String(projectId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View projects of current user
     * 
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectsIndex(offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<Projects>;
    public restSocialProjectsIndex(offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Projects>>;
    public restSocialProjectsIndex(offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Projects>>;
    public restSocialProjectsIndex(offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Projects>('get',`${this.basePath}/social/projects`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View the user&#x27;s invited as member projects list
     * 
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectsInvitationsIndex(offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<PaginatablePendingUserInvolvementsInProjects>;
    public restSocialProjectsInvitationsIndex(offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PaginatablePendingUserInvolvementsInProjects>>;
    public restSocialProjectsInvitationsIndex(offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PaginatablePendingUserInvolvementsInProjects>>;
    public restSocialProjectsInvitationsIndex(offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<PaginatablePendingUserInvolvementsInProjects>('get',`${this.basePath}/social/projects/invitations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View the user&#x27;s invited as owner projects list
     * 
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectsInvitationsIndexOwners(offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<PaginatablePendingUserInvolvementsInProjects>;
    public restSocialProjectsInvitationsIndexOwners(offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PaginatablePendingUserInvolvementsInProjects>>;
    public restSocialProjectsInvitationsIndexOwners(offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PaginatablePendingUserInvolvementsInProjects>>;
    public restSocialProjectsInvitationsIndexOwners(offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<PaginatablePendingUserInvolvementsInProjects>('get',`${this.basePath}/social/projects/owner/invitations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get counters for user projects social involvement
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectsInvolvementCountersGet(observe?: 'body', reportProgress?: boolean): Observable<RequestCounters>;
    public restSocialProjectsInvolvementCountersGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RequestCounters>>;
    public restSocialProjectsInvolvementCountersGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RequestCounters>>;
    public restSocialProjectsInvolvementCountersGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<RequestCounters>('get',`${this.basePath}/social/projects/involvement_counters`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new project
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectsPost(body: CreateProjectRequest, observe?: 'body', reportProgress?: boolean): Observable<Project>;
    public restSocialProjectsPost(body: CreateProjectRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Project>>;
    public restSocialProjectsPost(body: CreateProjectRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Project>>;
    public restSocialProjectsPost(body: CreateProjectRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restSocialProjectsPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Project>('post',`${this.basePath}/social/projects`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit project
     * 
     * @param body 
     * @param projectId Project ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectsPut(body: UpdateProjectRequest, projectId: string, observe?: 'body', reportProgress?: boolean): Observable<Project>;
    public restSocialProjectsPut(body: UpdateProjectRequest, projectId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Project>>;
    public restSocialProjectsPut(body: UpdateProjectRequest, projectId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Project>>;
    public restSocialProjectsPut(body: UpdateProjectRequest, projectId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restSocialProjectsPut.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling restSocialProjectsPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Project>('put',`${this.basePath}/social/project/${encodeURIComponent(String(projectId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View the user&#x27;s requested projects list
     * 
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialProjectsRequestsIndex(offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<PaginatablePendingUserInvolvementsInProjects>;
    public restSocialProjectsRequestsIndex(offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PaginatablePendingUserInvolvementsInProjects>>;
    public restSocialProjectsRequestsIndex(offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PaginatablePendingUserInvolvementsInProjects>>;
    public restSocialProjectsRequestsIndex(offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<PaginatablePendingUserInvolvementsInProjects>('get',`${this.basePath}/social/projects/requests`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View communities of specific user
     * 
     * @param userId User ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialUserCommunitiesIndex(userId: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<Communities>;
    public restSocialUserCommunitiesIndex(userId: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Communities>>;
    public restSocialUserCommunitiesIndex(userId: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Communities>>;
    public restSocialUserCommunitiesIndex(userId: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restSocialUserCommunitiesIndex.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Communities>('get',`${this.basePath}/social/${encodeURIComponent(String(userId))}/communities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View stats on current user&#x27;s social groups
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialUserGroupsStatsGet(observe?: 'body', reportProgress?: boolean): Observable<UserSocialGroupsStats>;
    public restSocialUserGroupsStatsGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserSocialGroupsStats>>;
    public restSocialUserGroupsStatsGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserSocialGroupsStats>>;
    public restSocialUserGroupsStatsGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<UserSocialGroupsStats>('get',`${this.basePath}/social/user_groups/stats`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * View projects of specific user
     * 
     * @param userId User ID
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit The numbers of items to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restSocialUserProjectsIndex(userId: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<Projects>;
    public restSocialUserProjectsIndex(userId: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Projects>>;
    public restSocialUserProjectsIndex(userId: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Projects>>;
    public restSocialUserProjectsIndex(userId: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restSocialUserProjectsIndex.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Projects>('get',`${this.basePath}/social/${encodeURIComponent(String(userId))}/projects`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Change password
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restUserChangePasswordPost(body: UserChangePassword, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restUserChangePasswordPost(body: UserChangePassword, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restUserChangePasswordPost(body: UserChangePassword, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restUserChangePasswordPost(body: UserChangePassword, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restUserChangePasswordPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/user/change_password`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes the specified user
     * 
     * @param userId User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restUserDelete(userId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public restUserDelete(userId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public restUserDelete(userId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public restUserDelete(userId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restUserDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/user/${encodeURIComponent(String(userId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches the specified user&#x27;s information from all contexts
     * 
     * @param userId User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restUserGet(userId: string, observe?: 'body', reportProgress?: boolean): Observable<FullUser>;
    public restUserGet(userId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FullUser>>;
    public restUserGet(userId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FullUser>>;
    public restUserGet(userId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restUserGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FullUser>('get',`${this.basePath}/user/${encodeURIComponent(String(userId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches all counsel users by type
     * 
     * @param counsel_role Fetches all counsel users
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restUserGetCounsel(counsel_role?: CounselRole, observe?: 'body', reportProgress?: boolean): Observable<CounselUsersByType>;
    public restUserGetCounsel(counsel_role?: CounselRole, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CounselUsersByType>>;
    public restUserGetCounsel(counsel_role?: CounselRole, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CounselUsersByType>>;
    public restUserGetCounsel(counsel_role?: CounselRole, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (counsel_role !== undefined && counsel_role !== null) {
            queryParameters = queryParameters.set('counsel_role', <any>counsel_role);
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<CounselUsersByType>('get',`${this.basePath}/users/counsel`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches all users
     * 
     * @param user_ids User IDs
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restUserIndex(user_ids?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<ListOfBasicUsers>;
    public restUserIndex(user_ids?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ListOfBasicUsers>>;
    public restUserIndex(user_ids?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ListOfBasicUsers>>;
    public restUserIndex(user_ids?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (user_ids) {
            user_ids.forEach((element) => {
                queryParameters = queryParameters.append('user_ids', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ListOfBasicUsers>('get',`${this.basePath}/users`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the specified user
     * 
     * @param body 
     * @param userId User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restUserPut(body: FullUserUpdateRequest, userId: string, observe?: 'body', reportProgress?: boolean): Observable<FullUser>;
    public restUserPut(body: FullUserUpdateRequest, userId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FullUser>>;
    public restUserPut(body: FullUserUpdateRequest, userId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FullUser>>;
    public restUserPut(body: FullUserUpdateRequest, userId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restUserPut.');
        }

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restUserPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (session) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<FullUser>('put',`${this.basePath}/user/${encodeURIComponent(String(userId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
